const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { PrismaClient } = require('@prisma/client');
const { ethers } = require('ethers');

const prisma = new PrismaClient();

class AuthService {
  // Valider une adresse Ethereum
  isValidAddress(address) {
    try {
      return ethers.isAddress(address);
    } catch (error) {
      return false;
    }
  }

  async login(address) {
    try {
      console.log(`üîê Tentative de connexion pour: ${address}`);
      
      // V√©rifier si l'utilisateur existe
      let user = await prisma.user.findUnique({
        where: { address: address.toLowerCase() }
      });

      // Cr√©er l'utilisateur s'il n'existe pas
      if (!user) {
        console.log(`üë§ Cr√©ation nouvel utilisateur: ${address}`);
        user = await prisma.user.create({
          data: {
            address: address.toLowerCase(),
            name: `User_${address.slice(-6)}`,
            isVerified: false
          }
        });
      }

      // Supprimer les anciennes sessions de cet utilisateur
      await prisma.userSession.deleteMany({
        where: { userId: user.id }
      });

      // G√©n√©rer un nouveau token unique
      const tokenPayload = {
        userId: user.id,
        address: user.address,
        timestamp: Date.now(),
        random: Math.random().toString(36)
      };

      const token = jwt.sign(tokenPayload, process.env.JWT_SECRET || 'default-secret', {
        expiresIn: '24h'
      });

      // Cr√©er une nouvelle session
      const expiresAt = new Date();
      expiresAt.setHours(expiresAt.getHours() + 24);

      const session = await prisma.userSession.create({
        data: {
          userId: user.id,
          token,
          expiresAt,
          isActive: true
        }
      });

      console.log(`‚úÖ Connexion r√©ussie pour: ${address}`);

      return {
        success: true,
        user: {
          id: user.id,
          address: user.address,
          name: user.name,
          isVerified: user.isVerified
        },
        token,
        expiresAt
      };

    } catch (error) {
      console.error('‚ùå Erreur login:', error);
      throw error;
    }
  }

  async verifyToken(token) {
    try {
      // V√©rifier le JWT
      const decoded = jwt.verify(token, process.env.JWT_SECRET || 'default-secret');
      
      // V√©rifier que la session existe et est active
      const session = await prisma.userSession.findFirst({
        where: {
          token,
          isActive: true,
          expiresAt: {
            gt: new Date()
          }
        },
        include: {
          user: true
        }
      });

      if (!session) {
        throw new Error('Session invalide ou expir√©e');
      }

      return {
        valid: true,
        user: session.user
      };

    } catch (error) {
      return {
        valid: false,
        error: error.message
      };
    }
  }

  async logout(token) {
    try {
      await prisma.userSession.updateMany({
        where: { token },
        data: { isActive: false }
      });

      return { success: true };
    } catch (error) {
      console.error('‚ùå Erreur logout:', error);
      throw error;
    }
  }

  async updateProfile(userId, profileData) {
    try {
      const user = await prisma.user.update({
        where: { id: userId },
        data: profileData
      });

      return {
        success: true,
        user: {
          id: user.id,
          address: user.address,
          name: user.name,
          isVerified: user.isVerified
        }
      };
    } catch (error) {
      console.error('‚ùå Erreur mise √† jour profil:', error);
      throw error;
    }
  }

  async createSession(userId, token) {
    try {
      const expiresAt = new Date();
      expiresAt.setHours(expiresAt.getHours() + 24); // 24h d'expiration

      const session = await prisma.userSession.create({
        data: {
          userId,
          token,
          expiresAt,
          isActive: true
        }
      });

      return session;
    } catch (error) {
      console.error('‚ùå Erreur cr√©ation session:', error);
      throw error;
    }
  }

  async hashPassword(password) {
    return bcrypt.hash(password, 10);
  }

  async comparePasswords(password, hashedPassword) {
    return bcrypt.compare(password, hashedPassword);
  }
}

module.exports = new AuthService();

  // üîß M√âTHODE MANQUANTE - Trouver ou cr√©er un utilisateur
  async findOrCreateUser(address, userData = {}) {
    try {
      console.log(`üîç Recherche utilisateur: ${address}`);
      
      // Normaliser l'adresse
      const normalizedAddress = address.toLowerCase();
      
      // Chercher l'utilisateur existant
      let user = await prisma.user.findUnique({
        where: { address: normalizedAddress }
      });

      // Si l'utilisateur n'existe pas, le cr√©er
      if (!user) {
        console.log(`üë§ Cr√©ation nouvel utilisateur: ${address}`);
        
        const userCreateData = {
          address: normalizedAddress,
          name: userData.name || `User_${address.slice(-6)}`,
          email: userData.email || null,
          firstName: userData.firstName || null,
          lastName: userData.lastName || null,
          country: userData.country || null,
          dateOfBirth: userData.dateOfBirth || null,
          role: userData.role || 'USER',
          isVerified: false,
          lastLogin: new Date()
        };

        user = await prisma.user.create({
          data: userCreateData
        });

        console.log(`‚úÖ Utilisateur cr√©√©: ${user.address}`);
      } else {
        // Mettre √† jour la derni√®re connexion
        user = await prisma.user.update({
          where: { id: user.id },
          data: { lastLogin: new Date() }
        });
        console.log(`‚úÖ Utilisateur trouv√©: ${user.address}`);
      }

      return user;
    } catch (error) {
      console.error('‚ùå Erreur findOrCreateUser:', error);
      throw error;
    }
  }

  // üîß M√âTHODE MANQUANTE - G√©n√©rer un token JWT
  generateToken(userId, address) {
    try {
      const payload = {
        userId,
        address,
        timestamp: Date.now(),
        random: Math.random().toString(36)
      };

      const token = jwt.sign(payload, process.env.JWT_SECRET || 'default-secret', {
        expiresIn: '24h'
      });

      console.log(`üé´ Token g√©n√©r√© pour user ${userId}`);
      return token;
    } catch (error) {
      console.error('‚ùå Erreur g√©n√©ration token:', error);
      throw error;
    }
  }

  // üîß M√âTHODE MANQUANTE - Cr√©er une session
  async createSession(userId, token, metadata = {}) {
    try {
      // Supprimer les anciennes sessions de cet utilisateur
      await prisma.userSession.deleteMany({
        where: { userId }
      });

      const expiresAt = new Date();
      expiresAt.setHours(expiresAt.getHours() + 24); // 24h d'expiration

      const session = await prisma.userSession.create({
        data: {
          userId,
          token,
          expiresAt,
          isActive: true,
          userAgent: metadata.userAgent || null,
          ipAddress: metadata.ipAddress || null
        }
      });

      console.log(`üìù Session cr√©√©e pour user ${userId}`);
      return session;
    } catch (error) {
      console.error('‚ùå Erreur cr√©ation session:', error);
      throw error;
    }
  }

  // üîß M√âTHODE MANQUANTE - R√©cup√©rer utilisateur par token
  async getUserByToken(token) {
    try {
      // V√©rifier le JWT
      const decoded = jwt.verify(token, process.env.JWT_SECRET || 'default-secret');
      
      // V√©rifier que la session existe et est active
      const session = await prisma.userSession.findFirst({
        where: {
          token,
          isActive: true,
          expiresAt: {
            gt: new Date()
          }
        },
        include: {
          user: true
        }
      });

      if (!session) {
        throw new Error('Session invalide ou expir√©e');
      }

      return session.user;
    } catch (error) {
      console.error('‚ùå Erreur getUserByToken:', error);
      throw error;
    }
  }

  // üîß M√âTHODE MANQUANTE - Nettoyer les sessions expir√©es
  async cleanExpiredSessions() {
    try {
      const result = await prisma.userSession.deleteMany({
        where: {
          OR: [
            { expiresAt: { lt: new Date() } },
            { isActive: false }
          ]
        }
      });

      console.log(`üßπ ${result.count} sessions expir√©es nettoy√©es`);
      return result.count;
    } catch (error) {
      console.error('‚ùå Erreur nettoyage sessions:', error);
      throw error;
    }
  }
